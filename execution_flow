Let’s build a practical, ready-to-run Continuous Delivery (CD) pipeline using Jenkins + Docker. I’ll give you:

Architecture + prerequisites

Quick setup (run Jenkins + local registry using Docker)

A production-ready Jenkinsfile (Declarative pipeline) that builds, tests, tags, pushes Docker images and deploys.

Example Dockerfile (multi-stage) + docker-compose for local testing.

Jenkins credentials / webhook notes + security tips

Quick troubleshooting checklist

All in one reply so you can copy-paste and run.

1 — Architecture (overview)

Git repo (GitHub/GitLab) holds app source + Dockerfile + Jenkinsfile.

Jenkins (master + agents) runs pipelines. Build runs on an agent with Docker available (either Docker-in-Docker or bind host Docker socket).

Docker registry (Docker Hub / private registry) stores images.

Target environment (production/staging) receives the image and runs containers (via Docker CLI, Docker Compose, or orchestrator e.g., Kubernetes).
Flow: push commit → Git webhook → Jenkins job triggers → stages: checkout → build/test → docker build → push image → deploy.

2 — Quick local setup (Jenkins + local registry)

You can test everything locally with Docker Compose:

# docker-compose.yml - Quick test environment: Jenkins + local registry
version: "3.8"
services:
  jenkins:
    image: jenkins/jenkins:lts
    privileged: true
    user: root
    ports:
      - "8080:8080"
      - "50000:50000"
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock   # allow Jenkins to use host Docker
    environment:
      - JAVA_OPTS=-Djenkins.install.runSetupWizard=false

  registry:
    image: registry:2
    ports:
      - "5000:5000"
    volumes:
      - registry_data:/var/lib/registry

volumes:
  jenkins_home:
  registry_data:


Run:

docker-compose up -d
# Jenkins UI: http://localhost:8080
# Local registry: localhost:5000


Note: Mapping /var/run/docker.sock is easy for testing but has security implications — see the security tips below.

3 — Example app Dockerfile (multi-stage, small Go/Node/Python example — adjust for your app)

Here's a generic multi-stage Dockerfile (build small artifact then produce slim runtime image):

# Dockerfile
# Stage 1 - build
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --production=false
COPY . .
RUN npm run build

# Stage 2 - runtime
FROM node:20-alpine
WORKDIR /app
COPY --from=build /app/dist ./dist
COPY package*.json ./
RUN npm ci --production=true
ENV NODE_ENV=production
EXPOSE 3000
CMD ["node", "dist/index.js"]


Adjust to your language/tooling (maven, go build, pip, etc.).

4 — Example Jenkinsfile (Declarative pipeline)

This Jenkinsfile builds, runs tests, builds Docker image, tags it with commit SHA and branch, pushes to registry, and deploys via SSH (or uses Docker on the target host). It uses Jenkins credentials for Docker registry and SSH.

// Jenkinsfile (Declarative)
pipeline {
  agent { label 'docker' } // ensure this agent has Docker CLI available
  environment {
    REGISTRY = "localhost:5000"           // update to Docker Hub or private registry e.g., myorg/myapp
    IMAGE_NAME = "${REGISTRY}/myapp"
  }
  options {
    // keep only last 10 builds
    buildDiscarder(logRotator(numToKeepStr: '10'))
    skipDefaultCheckout(true)
    timestamps()
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Install & Test') {
      steps {
        sh 'npm ci'
        sh 'npm test'   // adapt
      }
    }

    stage('Build Docker Image') {
      steps {
        script {
          // obtain short SHA for tagging
          def shortSha = sh(script: "git rev-parse --short=8 HEAD", returnStdout: true).trim()
          env.IMAGE_TAG = "${IMAGE_NAME}:${shortSha}"
        }
        sh "docker build -t ${IMAGE_TAG} ."
        // create :latest for branch name (optional)
        sh "docker tag ${IMAGE_TAG} ${IMAGE_NAME}:latest"
      }
    }

    stage('Login & Push') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'docker-registry-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin ${REGISTRY}
            docker push ${IMAGE_TAG}
            docker push ${IMAGE_NAME}:latest
          '''
        }
      }
    }

    stage('Deploy') {
      steps {
        // Example: deploy via SSH to remote host (assumes target has docker installed and 'deploy' user)
        // credentialId 'deploy-ssh-key' is an SSH private key stored in Jenkins.
        withCredentials([sshUserPrivateKey(credentialsId: 'deploy-ssh-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'DEPLOY_USER')]) {
          sh """
            chmod 600 $SSH_KEY
            ssh -o StrictHostKeyChecking=no -i $SSH_KEY ${DEPLOY_USER}@production.example.com <<'EOF'
              docker pull ${IMAGE_TAG}
              docker rm -f myapp || true
              docker run -d --name myapp -p 80:3000 --restart=always ${IMAGE_TAG}
            EOF
          """
        }
      }
    }
  }
  post {
    success {
      echo "Pipeline succeeded: ${IMAGE_TAG}"
    }
    failure {
      echo "Pipeline failed."
    }
  }
}


Notes on the Jenkinsfile:

agent { label 'docker' } — ensure you have an agent labeled docker that has Docker CLI and network access to the registry.

Create Jenkins credentials:

docker-registry-creds → Username/password (Docker Hub or registry)

deploy-ssh-key → SSH Username with private key (for remote deploy)

If you use Docker Hub, set REGISTRY = "docker.io/youruser" and push with docker login accordingly.

5 — Jenkins setup specifics

Install necessary Jenkins plugins:

Pipeline, GitHub/GitLab plugin, Docker Pipeline (optional), SSH Agent, Credentials Binding.

Jenkins agents:

Option A (fast): Use the same Jenkins host and bind /var/run/docker.sock. Jenkins must run as root or a user with Docker privileges.

Option B (recommended for production): Run a dedicated build agent container/image with Docker CLI + Docker daemon access via Docker-in-Docker (dind) or connect to remote Docker Engine (safer is to use an agent image with docker CLI and talk to a remote Docker host via TLS).

Add Credentials:

docker-registry-creds — username/password for registry.

deploy-ssh-key — private key for SSH deploy.

Connect repository:

Create a pipeline job (multibranch pipeline if you want branch-based pipelines).

Configure webhook on GitHub: send push events to http://<jenkins>/github-webhook/.

6 — Local test with docker-compose (for dev)

docker-compose.yml to run the app locally (if your image is called myapp:latest):

version: '3.8'
services:
  app:
    image: localhost:5000/myapp:latest
    ports:
      - "3000:3000"
    restart: unless-stopped


Pull image and run:

docker-compose pull
docker-compose up -d

7 — Best practices & security notes

Avoid mounting Docker socket in production Jenkins agents — it gives full host control. Use remote Docker engines with TLS or Kubernetes agents instead.

Credential management: store secrets in Jenkins Credentials or HashiCorp Vault. Never commit secrets in code.

Image tags: use immutable tags (SHA-based). Keep latest only as a convenience.

Scanning: Integrate image scanning (Trivy/Clair) as a pipeline stage.

Rollback: add stage to tag previous image and allow quick rollback. Store deploy manifest with image tags.

Non-root in containers: run app containers as non-root where possible.

Multibranch Pipeline: use for PR builds, branch protection, and automatic branch jobs.

8 — Extra: add unit/integration test stage & approval for prod

You can insert a manual input step before the Deploy stage for production:

stage('Approve Deploy') {
  when { branch 'main' }
  steps {
    input message: "Approve deploy to production?", ok: "Deploy"
  }
}

9 — Troubleshooting checklist

Jenkins can't build Docker image: ensure agent has Docker CLI & access to daemon.

docker login fails in pipeline: check credentialsId and scopes.

Webhook not triggering: ensure Jenkins endpoint accessible from Git host, and job SCM config matches.

Deploy SSH fails: check key permissions, user access, and StrictHostKeyChecking.

10 — Quick next steps (copy-paste)

Put Dockerfile and Jenkinsfile in repo root.

Start local registry + Jenkins with docker-compose up -d.

Create Jenkins credentials docker-registry-creds and deploy-ssh-key.

Create multibranch pipeline pointing to your repo or a pipeline job referencing Jenkinsfile.

Push a commit — watch Jenkins run the pipeline.
